<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="c9179a65-76da-427c-a06c-058b82b1bf8a" name="Changes" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" beforeDir="false" afterPath="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Interface" />
        <option value="Enum" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <excluded-from-favorite>
      <branch-storage>
        <map>
          <entry type="LOCAL">
            <value>
              <list>
                <branch-info repo="$PROJECT_DIR$" source="master" />
              </list>
            </value>
          </entry>
        </map>
      </branch-storage>
    </excluded-from-favorite>
    <option name="RECENT_BRANCH_BY_REPOSITORY">
      <map>
        <entry key="$PROJECT_DIR$" value="master" />
      </map>
    </option>
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="HighlightingSettingsPerFile">
    <setting file="file://$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/ClientApplication.java" root0="SKIP_INSPECTION" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 2
}</component>
  <component name="ProjectId" id="2igNHmocjqj0WzEv6ME2h7UHOZx" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,
    &quot;Application.ClientApplication.executor&quot;: &quot;Run&quot;,
    &quot;Application.Main (1).executor&quot;: &quot;Run&quot;,
    &quot;Application.Main.executor&quot;: &quot;Run&quot;,
    &quot;Application.ServerApplication.executor&quot;: &quot;Run&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,
    &quot;last_opened_file_path&quot;: &quot;C:/Users/xa86/IdeaProjects/learning-project/basic-homeworks&quot;,
    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
  }
}</component>
  <component name="RunManager" selected="Application.ClientApplication">
    <configuration name="ClientApplication" type="Application" factoryName="Application" singleton="false" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.basic.ClientApplication" />
      <module name="client" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.basic.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="ServerApplication" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.basic.ServerApplication" />
      <module name="server" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.basic.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <list>
      <item itemvalue="Application.ClientApplication" />
      <item itemvalue="Application.ServerApplication" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Application.ClientApplication" />
        <item itemvalue="Application.ServerApplication" />
        <item itemvalue="Application.ServerApplication" />
        <item itemvalue="Application.ClientApplication" />
        <item itemvalue="Application.ClientApplication" />
      </list>
    </recent_temporary>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-jdk-9f38398b9061-18abd8497189-intellij.indexing.shared.core-IU-241.14494.240" />
        <option value="bundled-js-predefined-1d06a55b98c1-74d2a5396914-JavaScript-IU-241.14494.240" />
      </set>
    </attachedChunks>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="c9179a65-76da-427c-a06c-058b82b1bf8a" name="Changes" comment="" />
      <created>1719908176695</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1719908176695</updated>
      <workItem from="1719908177822" duration="3286000" />
    </task>
    <task id="LOCAL-00001" summary="master branch commit">
      <option name="closed" value="true" />
      <created>1719909096404</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1719909096404</updated>
    </task>
    <task id="LOCAL-00002" summary="Homework fifteen basic implementation">
      <option name="closed" value="true" />
      <created>1719910070157</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1719910070157</updated>
    </task>
    <option name="localTasksCounter" value="3" />
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
    <MESSAGE value="master branch commit" />
    <MESSAGE value="Homework fifteen basic implementation" />
    <option name="LAST_COMMIT_MESSAGE" value="Homework fifteen basic implementation" />
  </component>
  <component name="com.github.evgenys91.machinet.common.dslhistory.DslHistoryState">
    <option name="historyDtoById">
      <map>
        <entry key="562609">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                </list>
              </option>
              <option name="id" value="562609" />
              <option name="initiateTms" value="1719910267003" />
              <option name="request" value=" Реализуйте возможность отправки личных сообщений: если клиент пишет «/w tom Hello», то сообщение Hello должно быть отправлено только клиенту с ником tom" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для реализации возможности отправки личных сообщений, необходимо внести изменения в классы `ClientHandler` и `Server`. Мы добавим метод для отправки личных сообщений в `Server` и изменим обработку сообщений в `ClientHandler`.&#10;&#10;### Изменения в `Server.java`&#10;&#10;Добавим метод `sendPrivateMessage` для отправки личных сообщений:&#10;&#10;```java&#10;public class Server {&#10;    private int port;&#10;    private List&lt;ClientHandler&gt; clients;&#10;&#10;    public Server(int port) {&#10;        this.port = port;&#10;        this.clients = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    public void start() {&#10;        try (ServerSocket serverSocket = new ServerSocket(port)) {&#10;            System.out.println(&quot;Сервер запущен на порту: &quot; + port);&#10;            while (true) {&#10;                Socket socket = serverSocket.accept();&#10;                subscribe(new ClientHandler(this, socket));&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public synchronized void subscribe(ClientHandler clientHandler) {&#10;        broadcastMessage(&quot;В чат зашел: &quot; + clientHandler.getUsername());&#10;        clients.add(clientHandler);&#10;    }&#10;&#10;    public synchronized void unsubscribe(ClientHandler clientHandler) {&#10;        clients.remove(clientHandler);&#10;        broadcastMessage(&quot;Из чата вышел: &quot; + clientHandler.getUsername());&#10;    }&#10;&#10;    public synchronized void broadcastMessage(String message) {&#10;        for (ClientHandler c : clients) {&#10;            c.sendMessage(message);&#10;        }&#10;    }&#10;&#10;    public synchronized void sendPrivateMessage(String recipientUsername, String message) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(recipientUsername)) {&#10;                client.sendMessage(message);&#10;                break;&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `ClientHandler.java`&#10;&#10;Изменим обработку сообщений, чтобы поддерживать отправку личных сообщений:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.io.DataInputStream;&#10;import java.io.DataOutputStream;&#10;import java.io.IOException;&#10;import java.net.Socket;&#10;&#10;public class ClientHandler {&#10;    private Server server;&#10;    private Socket socket;&#10;    private DataInputStream in;&#10;    private DataOutputStream out;&#10;&#10;    private String username;&#10;&#10;    private static int usersCount = 0;&#10;&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    public ClientHandler(Server server, Socket socket) throws IOException {&#10;        this.server = server;&#10;        this.socket = socket;&#10;        this.in = new DataInputStream(socket.getInputStream());&#10;        this.out = new DataOutputStream(socket.getOutputStream());&#10;        usersCount++;&#10;        this.username = &quot;user&quot; + usersCount;&#10;        new Thread(() -&gt; {&#10;            try {&#10;                System.out.println(&quot;Подключился новый клиент&quot;);&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.startsWith(&quot;/&quot;)) {&#10;                        if (message.equals(&quot;/exit&quot;)) {&#10;                            sendMessage(&quot;/exitok&quot;);&#10;                            break;&#10;                        } else if (message.startsWith(&quot;/w &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 3);&#10;                            if (parts.length == 3) {&#10;                                String recipient = parts[1];&#10;                                String privateMessage = parts[2];&#10;                                server.sendPrivateMessage(recipient, username + &quot; (личное сообщение): &quot; + privateMessage);&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат личного сообщения. Используйте: /w &lt;username&gt; &lt;message&gt;&quot;);&#10;                            }&#10;                        }&#10;                        continue;&#10;                    }&#10;                    server.broadcastMessage(username + &quot;: &quot; + message);&#10;                }&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            } finally {&#10;                disconnect();&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void sendMessage(String message) {&#10;        try {&#10;            out.writeUTF(message);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void disconnect() {&#10;        server.unsubscribe(this);&#10;        try {&#10;            if (in != null) {&#10;                in.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (out != null) {&#10;                out.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (socket != null) {&#10;                socket.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;Теперь, если клиент отправит сообщение в формате `/w &lt;username&gt; &lt;message&gt;`, оно будет доставлено только указанному пользователю." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1719910288608" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="82e491">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                </list>
              </option>
              <option name="id" value="82e491" />
              <option name="initiateTms" value="1719914114180" />
              <option name="request" value=" У меня нет класса ENUM Role" />
              <option name="response" value="" />
              <option name="responseDescription" value="Понял, давайте добавим класс `Role` и внесем необходимые изменения в существующие классы для реализации возможности отключения пользователей от чата с помощью команды «/kick username» для пользователей с ролью `ADMIN`.&#10;&#10;### Добавление класса `Role`&#10;&#10;Создадим новый файл `Role.java` в соответствующем пакете:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;public enum Role {&#10;    USER,&#10;    ADMIN&#10;}&#10;```&#10;&#10;### Изменения в `InMemoryAuthenticationProvider.java`&#10;&#10;Добавим метод `getUserRole` для получения роли пользователя по логину:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class InMemoryAuthenticationProvider implements AuthenticationProvider {&#10;    private class User {&#10;        private String login;&#10;        private String password;&#10;        private String username;&#10;        private Role role;&#10;&#10;        public User(String login, String password, String username, Role role) {&#10;            this.login = login;&#10;            this.password = password;&#10;            this.username = username;&#10;            this.role = role;&#10;        }&#10;&#10;        public String getLogin() {&#10;            return login;&#10;        }&#10;&#10;        public Role getRole() {&#10;            return role;&#10;        }&#10;&#10;        public String getUsername() {&#10;            return username;&#10;        }&#10;    }&#10;&#10;    private Server server;&#10;    private List&lt;User&gt; users;&#10;&#10;    public InMemoryAuthenticationProvider(Server server) {&#10;        this.server = server;&#10;        this.users = new ArrayList&lt;&gt;();&#10;        this.users.add(new User(&quot;login1&quot;, &quot;pass1&quot;, &quot;bob&quot;, Role.ADMIN));&#10;        this.users.add(new User(&quot;login2&quot;, &quot;pass2&quot;, &quot;user2&quot;, Role.USER));&#10;        this.users.add(new User(&quot;login3&quot;, &quot;pass3&quot;, &quot;user3&quot;, Role.USER));&#10;    }&#10;&#10;    @Override&#10;    public void initialize() {&#10;        System.out.println(&quot;Сервис аутентификации запущен: In-Memory режим&quot;);&#10;    }&#10;&#10;    private String getUsernameByLoginAndPassword(String login, String password) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login) &amp;&amp; u.password.equals(password)) {&#10;                return u.username;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private boolean isLoginAlreadyExist(String login) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean isUsernameAlreadyExist(String username) {&#10;        for (User u : users) {&#10;            if (u.username.equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public synchronized boolean authenticate(ClientHandler clientHandler, String login, String password) {&#10;        String authUsername = getUsernameByLoginAndPassword(login, password);&#10;        if (authUsername == null) {&#10;            clientHandler.sendMessage(&quot;Некорректный логин/пароль&quot;);&#10;            return false;&#10;        }&#10;        if (server.isUsernameBusy(authUsername)) {&#10;            clientHandler.sendMessage(&quot;Указанная учетная запись уже занята&quot;);&#10;            return false;&#10;        }&#10;        clientHandler.setUsername(authUsername);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/authok &quot; + authUsername);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean registration(ClientHandler clientHandler, String login, String password, String username) {&#10;        if (login.trim().length() &lt; 3 || password.trim().length() &lt; 6 || username.trim().length() &lt; 1) {&#10;            clientHandler.sendMessage(&quot;Логин 3+ символа, Пароль 6+ символов, Имя пользователя 1+ символ&quot;);&#10;            return false;&#10;        }&#10;        if (isLoginAlreadyExist(login)) {&#10;            clientHandler.sendMessage(&quot;Указанный логин уже занят&quot;);&#10;            return false;&#10;        }&#10;        if (isUsernameAlreadyExist(username)) {&#10;            clientHandler.sendMessage(&quot;Указанное имя пользователя уже занято&quot;);&#10;            return false;&#10;        }&#10;        users.add(new User(login, password, username, Role.USER));&#10;        clientHandler.setUsername(username);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/regok &quot; + username);&#10;        return true;&#10;    }&#10;&#10;    public boolean removeUserByLogin(String login) {&#10;        return users.removeIf(user -&gt; user.getLogin().equals(login));&#10;    }&#10;&#10;    public Role getUserRole(String username) {&#10;        for (User user : users) {&#10;            if (user.getUsername().equals(username)) {&#10;                return user.getRole();&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `Server.java`&#10;&#10;Добавим метод `kickUser` для отключения пользователя:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Server {&#10;    private int port;&#10;    private List&lt;ClientHandler&gt; clients;&#10;    private AuthenticationProvider authenticationProvider;&#10;&#10;    public AuthenticationProvider getAuthenticationProvider() {&#10;        return authenticationProvider;&#10;    }&#10;&#10;    public Server(int port) {&#10;        this.port = port;&#10;        this.clients = new ArrayList&lt;&gt;();&#10;        this.authenticationProvider = new InMemoryAuthenticationProvider(this);&#10;    }&#10;&#10;    public void start() {&#10;        try (ServerSocket serverSocket = new ServerSocket(port)) {&#10;            System.out.println(&quot;Сервер запущен на порту: &quot; + port);&#10;            authenticationProvider.initialize();&#10;            while (true) {&#10;                Socket socket = serverSocket.accept();&#10;                new ClientHandler(this, socket);&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public synchronized void subscribe(ClientHandler clientHandler) {&#10;        broadcastMessage(&quot;В чат зашел: &quot; + clientHandler.getUsername());&#10;        clients.add(clientHandler);&#10;    }&#10;&#10;    public synchronized void unsubscribe(ClientHandler clientHandler) {&#10;        clients.remove(clientHandler);&#10;        broadcastMessage(&quot;Из чата вышел: &quot; + clientHandler.getUsername());&#10;    }&#10;&#10;    public synchronized void broadcastMessage(String message) {&#10;        for (ClientHandler c : clients) {&#10;            c.sendMessage(message);&#10;        }&#10;    }&#10;&#10;    public synchronized void sendPrivateMessage(String recipientUsername, String message) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(recipientUsername)) {&#10;                client.sendMessage(message);&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    public synchronized void kickUser(String username) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(username)) {&#10;                client.sendMessage(&quot;Вы были отключены от чата администратором.&quot;);&#10;                client.disconnect();&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean isUsernameBusy(String username) {&#10;        for (ClientHandler c : clients) {&#10;            if (c.getUsername().equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `ClientHandler.java`&#10;&#10;Изменим обработку сообщений, чтобы поддерживать команду `/kick` для администраторов:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.io.DataInputStream;&#10;import java.io.DataOutputStream;&#10;import java.io.IOException;&#10;import java.net.Socket;&#10;&#10;public class ClientHandler {&#10;    private Server server;&#10;    private Socket socket;&#10;    private DataInputStream in;&#10;    private DataOutputStream out;&#10;    private String username;&#10;&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    public void setUsername(String username) {&#10;        this.username = username;&#10;    }&#10;&#10;    public ClientHandler(Server server, Socket socket) throws IOException {&#10;        this.server = server;&#10;        this.socket = socket;&#10;        this.in = new DataInputStream(socket.getInputStream());&#10;        this.out = new DataOutputStream(socket.getOutputStream());&#10;        new Thread(() -&gt; {&#10;            try {&#10;                System.out.println(&quot;Подключился новый клиент&quot;);&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.equals(&quot;/exit&quot;)) {&#10;                        sendMessage(&quot;/exitok&quot;);&#10;                        return;&#10;                    }&#10;                    if (message.startsWith(&quot;/auth &quot;)) {&#10;                        String[] elements = message.split(&quot; &quot;);&#10;                        if (elements.length != 3) {&#10;                            sendMessage(&quot;Неверный формат команды /auth&quot;);&#10;                            continue;&#10;                        }&#10;                        if (server.getAuthenticationProvider().authenticate(this, elements[1], elements[2])) {&#10;                            break;&#10;                        }&#10;                        continue;&#10;                    }&#10;                    if (message.startsWith(&quot;/register &quot;)) {&#10;                        String[] elements = message.split(&quot; &quot;);&#10;                        if (elements.length != 4) {&#10;                            sendMessage(&quot;Неверный формат команды /register&quot;);&#10;                            continue;&#10;                        }&#10;                        if (server.getAuthenticationProvider().registration(this, elements[1], elements[2], elements[3])) {&#10;                            break;&#10;                        }&#10;                        continue;&#10;                    }&#10;                    sendMessage(&quot;Перед работой с чатом необходимо выполнить аутентификацию '/auth login password' или регистрацию '/register login password username'&quot;);&#10;                }&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.startsWith(&quot;/&quot;)) {&#10;                        if (message.equals(&quot;/exit&quot;)) {&#10;                            sendMessage(&quot;/exitok&quot;);&#10;                            break;&#10;                        } else if (message.startsWith(&quot;/w &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 3);&#10;                            if (parts.length == 3) {&#10;                                String recipient = parts[1];&#10;                                String privateMessage = parts[2];&#10;                                server.sendPrivateMessage(recipient, username + &quot; (личное сообщение): &quot; + privateMessage);&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат личного сообщения. Используйте: /w &lt;username&gt; &lt;message&gt;&quot;);&#10;                            }&#10;                        } else if (message.startsWith(&quot;/kick &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 2);&#10;                            if (parts.length == 2) {&#10;                                String userToKick = parts[1];&#10;                                Role role = server.getAuthenticationProvider().getUserRole(username);&#10;                                if (Role.ADMIN.equals(role)) {&#10;                                    server.kickUser(userToKick);&#10;                                } else {&#10;                                    sendMessage(&quot;У вас нет прав для выполнения этой команды.&quot;);&#10;                                }&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат команды. Используйте: /kick &lt;username&gt;&quot;);&#10;                            }&#10;                        }&#10;                        continue;&#10;                    }&#10;                    server.broadcastMessage(username + &quot;: &quot; + message);&#10;                }&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            } finally {&#10;                disconnect();&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void sendMessage(String message) {&#10;        try {&#10;            out.writeUTF(message);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void disconnect() {&#10;        server.unsubscribe(this);&#10;        try {&#10;            if (in != null) {&#10;                in.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (out != null) {&#10;                out.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (socket != null) {&#10;                socket.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;Теперь пользователи с ролью `ADMIN` могут отключать других пользователей от чата с помощью команды `/kick &lt;username&gt;`." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1719914175239" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="855854">
          <value>
            <ChatHistoryModel>
              <option name="id" value="855854" />
              <option name="initiateTms" value="1719914105045" />
              <option name="isStopped" value="true" />
              <option name="request" value=" У меня нет класса ENUM Кщду" />
              <option name="response" value="" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="e916bb">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/enums/Role.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                </list>
              </option>
              <option name="id" value="e916bb" />
              <option name="initiateTms" value="1719913807541" />
              <option name="request" value=" как из private List&lt;User&gt; users; удалить         this.users.add(new User(&quot;login1&quot;, &quot;pass1&quot;, &quot;bob&quot;, Role.ADMIN.name()));&#10;по логину который тут &quot;bob&quot;" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для удаления пользователя из списка `users` по логину, можно создать метод в классе `InMemoryAuthenticationProvider`, который будет искать пользователя по логину и удалять его. Воспользуемся методом `removeIf` из интерфейса `List`, который позволяет удалить элементы, соответствующие заданному условию.&#10;&#10;Вот как это можно сделать:&#10;&#10;### Изменения в `InMemoryAuthenticationProvider.java`&#10;&#10;Добавим метод `removeUserByLogin`:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import ru.otus.java.basic.enums.Role;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class InMemoryAuthenticationProvider implements AuthenticationProvider {&#10;    private class User {&#10;        private String login;&#10;        private String password;&#10;        private String username;&#10;        private String role;&#10;&#10;        public User(String login, String password, String username, String role) {&#10;            this.login = login;&#10;            this.password = password;&#10;            this.username = username;&#10;            this.role = role;&#10;        }&#10;&#10;        public String getLogin() {&#10;            return login;&#10;        }&#10;    }&#10;&#10;    private Server server;&#10;    private List&lt;User&gt; users;&#10;&#10;    public InMemoryAuthenticationProvider(Server server) {&#10;        this.server = server;&#10;        this.users = new ArrayList&lt;&gt;();&#10;        this.users.add(new User(&quot;login1&quot;, &quot;pass1&quot;, &quot;bob&quot;, Role.ADMIN.name()));&#10;        this.users.add(new User(&quot;login2&quot;, &quot;pass2&quot;, &quot;user2&quot;, Role.USER.name()));&#10;        this.users.add(new User(&quot;login3&quot;, &quot;pass3&quot;, &quot;user3&quot;, Role.USER.name()));&#10;    }&#10;&#10;    @Override&#10;    public void initialize() {&#10;        System.out.println(&quot;Сервис аутентификации запущен: In-Memory режим&quot;);&#10;    }&#10;&#10;    private String getUsernameByLoginAndPassword(String login, String password) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login) &amp;&amp; u.password.equals(password)) {&#10;                return u.username;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private boolean isLoginAlreadyExist(String login) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean isUsernameAlreadyExist(String username) {&#10;        for (User u : users) {&#10;            if (u.username.equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public synchronized boolean authenticate(ClientHandler clientHandler, String login, String password) {&#10;        String authUsername = getUsernameByLoginAndPassword(login, password);&#10;        if (authUsername == null) {&#10;            clientHandler.sendMessage(&quot;Некорретный логин/пароль&quot;);&#10;            return false;&#10;        }&#10;        if (server.isUsernameBusy(authUsername)) {&#10;            clientHandler.sendMessage(&quot;Указанная учетная запись уже занята&quot;);&#10;            return false;&#10;        }&#10;        clientHandler.setUsername(authUsername);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/authok &quot; + authUsername);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean registration(ClientHandler clientHandler, String login, String password, String username) {&#10;        if (login.trim().length() &lt; 3 || password.trim().length() &lt; 6 || username.trim().length() &lt; 1) {&#10;            clientHandler.sendMessage(&quot;Логин 3+ символа, Пароль 6+ символов, Имя пользователя 1+ символ&quot;);&#10;            return false;&#10;        }&#10;        if (isLoginAlreadyExist(login)) {&#10;            clientHandler.sendMessage(&quot;Указанный логин уже занят&quot;);&#10;            return false;&#10;        }&#10;        if (isUsernameAlreadyExist(username)) {&#10;            clientHandler.sendMessage(&quot;Указанное имя пользователя уже занято&quot;);&#10;            return false;&#10;        }&#10;        users.add(new User(login, password, username, Role.USER.name()));&#10;        clientHandler.setUsername(username);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/regok &quot; + username);&#10;        return true;&#10;    }&#10;&#10;    public boolean removeUserByLogin(String login) {&#10;        return users.removeIf(user -&gt; user.getLogin().equals(login));&#10;    }&#10;}&#10;```&#10;&#10;Теперь вы можете удалить пользователя по логину, вызвав метод `removeUserByLogin`:&#10;&#10;```java&#10;InMemoryAuthenticationProvider authProvider = new InMemoryAuthenticationProvider(server);&#10;boolean removed = authProvider.removeUserByLogin(&quot;login1&quot;);&#10;if (removed) {&#10;    System.out.println(&quot;Пользователь с логином 'login1' был удален.&quot;);&#10;} else {&#10;    System.out.println(&quot;Пользователь с логином 'login1' не найден.&quot;);&#10;}&#10;```&#10;&#10;Этот метод удалит пользователя с указанным логином из списка `users` и вернет `true`, если пользователь был найден и удален, или `false`, если пользователь с таким логином не был найден." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1719913860595" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/enums/Role.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="f414ff">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/enums/Role.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                </list>
              </option>
              <option name="id" value="f414ff" />
              <option name="initiateTms" value="1719913902157" />
              <option name="request" value=" Точнее задача звучит:&#10;&#10;    Добавьте пользователям роли: USER, ADMIN&#10;    Для пользователей с ролью ADMIN реализуйте возможность отключения пользователей от чата с помощью команды «/kick username»" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для реализации возможности отключения пользователей от чата с помощью команды «/kick username» для пользователей с ролью `ADMIN`, необходимо внести изменения в классы `ClientHandler`, `Server`, и `InMemoryAuthenticationProvider`.&#10;&#10;### Изменения в `InMemoryAuthenticationProvider.java`&#10;&#10;Добавим метод `getUserRole` для получения роли пользователя по логину:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import ru.otus.java.basic.enums.Role;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class InMemoryAuthenticationProvider implements AuthenticationProvider {&#10;    private class User {&#10;        private String login;&#10;        private String password;&#10;        private String username;&#10;        private String role;&#10;&#10;        public User(String login, String password, String username, String role) {&#10;            this.login = login;&#10;            this.password = password;&#10;            this.username = username;&#10;            this.role = role;&#10;        }&#10;&#10;        public String getLogin() {&#10;            return login;&#10;        }&#10;&#10;        public String getRole() {&#10;            return role;&#10;        }&#10;&#10;        public String getUsername() {&#10;            return username;&#10;        }&#10;    }&#10;&#10;    private Server server;&#10;    private List&lt;User&gt; users;&#10;&#10;    public InMemoryAuthenticationProvider(Server server) {&#10;        this.server = server;&#10;        this.users = new ArrayList&lt;&gt;();&#10;        this.users.add(new User(&quot;login1&quot;, &quot;pass1&quot;, &quot;bob&quot;, Role.ADMIN.name()));&#10;        this.users.add(new User(&quot;login2&quot;, &quot;pass2&quot;, &quot;user2&quot;, Role.USER.name()));&#10;        this.users.add(new User(&quot;login3&quot;, &quot;pass3&quot;, &quot;user3&quot;, Role.USER.name()));&#10;    }&#10;&#10;    @Override&#10;    public void initialize() {&#10;        System.out.println(&quot;Сервис аутентификации запущен: In-Memory режим&quot;);&#10;    }&#10;&#10;    private String getUsernameByLoginAndPassword(String login, String password) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login) &amp;&amp; u.password.equals(password)) {&#10;                return u.username;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private boolean isLoginAlreadyExist(String login) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean isUsernameAlreadyExist(String username) {&#10;        for (User u : users) {&#10;            if (u.username.equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public synchronized boolean authenticate(ClientHandler clientHandler, String login, String password) {&#10;        String authUsername = getUsernameByLoginAndPassword(login, password);&#10;        if (authUsername == null) {&#10;            clientHandler.sendMessage(&quot;Некорректный логин/пароль&quot;);&#10;            return false;&#10;        }&#10;        if (server.isUsernameBusy(authUsername)) {&#10;            clientHandler.sendMessage(&quot;Указанная учетная запись уже занята&quot;);&#10;            return false;&#10;        }&#10;        clientHandler.setUsername(authUsername);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/authok &quot; + authUsername);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean registration(ClientHandler clientHandler, String login, String password, String username) {&#10;        if (login.trim().length() &lt; 3 || password.trim().length() &lt; 6 || username.trim().length() &lt; 1) {&#10;            clientHandler.sendMessage(&quot;Логин 3+ символа, Пароль 6+ символов, Имя пользователя 1+ символ&quot;);&#10;            return false;&#10;        }&#10;        if (isLoginAlreadyExist(login)) {&#10;            clientHandler.sendMessage(&quot;Указанный логин уже занят&quot;);&#10;            return false;&#10;        }&#10;        if (isUsernameAlreadyExist(username)) {&#10;            clientHandler.sendMessage(&quot;Указанное имя пользователя уже занято&quot;);&#10;            return false;&#10;        }&#10;        users.add(new User(login, password, username, Role.USER.name()));&#10;        clientHandler.setUsername(username);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/regok &quot; + username);&#10;        return true;&#10;    }&#10;&#10;    public boolean removeUserByLogin(String login) {&#10;        return users.removeIf(user -&gt; user.getLogin().equals(login));&#10;    }&#10;&#10;    public String getUserRole(String username) {&#10;        for (User user : users) {&#10;            if (user.getUsername().equals(username)) {&#10;                return user.getRole();&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `Server.java`&#10;&#10;Добавим метод `kickUser` для отключения пользователя:&#10;&#10;```java&#10;public class Server {&#10;    private int port;&#10;    private List&lt;ClientHandler&gt; clients;&#10;    private AuthenticationProvider authenticationProvider;&#10;&#10;    public Server(int port) {&#10;        this.port = port;&#10;        this.clients = new ArrayList&lt;&gt;();&#10;        this.authenticationProvider = new InMemoryAuthenticationProvider(this);&#10;    }&#10;&#10;    public void start() {&#10;        try (ServerSocket serverSocket = new ServerSocket(port)) {&#10;            System.out.println(&quot;Сервер запущен на порту: &quot; + port);&#10;            authenticationProvider.initialize();&#10;            while (true) {&#10;                Socket socket = serverSocket.accept();&#10;                new ClientHandler(this, socket);&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public synchronized void subscribe(ClientHandler clientHandler) {&#10;        broadcastMessage(&quot;В чат зашел: &quot; + clientHandler.getUsername());&#10;        clients.add(clientHandler);&#10;    }&#10;&#10;    public synchronized void unsubscribe(ClientHandler clientHandler) {&#10;        clients.remove(clientHandler);&#10;        broadcastMessage(&quot;Из чата вышел: &quot; + clientHandler.getUsername());&#10;    }&#10;&#10;    public synchronized void broadcastMessage(String message) {&#10;        for (ClientHandler c : clients) {&#10;            c.sendMessage(message);&#10;        }&#10;    }&#10;&#10;    public synchronized void sendPrivateMessage(String recipientUsername, String message) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(recipientUsername)) {&#10;                client.sendMessage(message);&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    public synchronized void kickUser(String username) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(username)) {&#10;                client.sendMessage(&quot;Вы были отключены от чата администратором.&quot;);&#10;                client.disconnect();&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean isUsernameBusy(String username) {&#10;        for (ClientHandler c : clients) {&#10;            if (c.getUsername().equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public AuthenticationProvider getAuthenticationProvider() {&#10;        return authenticationProvider;&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `ClientHandler.java`&#10;&#10;Изменим обработку сообщений, чтобы поддерживать команду `/kick` для администраторов:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.io.DataInputStream;&#10;import java.io.DataOutputStream;&#10;import java.io.IOException;&#10;import java.net.Socket;&#10;&#10;public class ClientHandler {&#10;    private Server server;&#10;    private Socket socket;&#10;    private DataInputStream in;&#10;    private DataOutputStream out;&#10;    private String username;&#10;&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    public void setUsername(String username) {&#10;        this.username = username;&#10;    }&#10;&#10;    public ClientHandler(Server server, Socket socket) throws IOException {&#10;        this.server = server;&#10;        this.socket = socket;&#10;        this.in = new DataInputStream(socket.getInputStream());&#10;        this.out = new DataOutputStream(socket.getOutputStream());&#10;        new Thread(() -&gt; {&#10;            try {&#10;                System.out.println(&quot;Подключился новый клиент&quot;);&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.equals(&quot;/exit&quot;)) {&#10;                        sendMessage(&quot;/exitok&quot;);&#10;                        return;&#10;                    }&#10;                    if (message.startsWith(&quot;/auth &quot;)) {&#10;                        String[] elements = message.split(&quot; &quot;);&#10;                        if (elements.length != 3) {&#10;                            sendMessage(&quot;Неверный формат команды /auth&quot;);&#10;                            continue;&#10;                        }&#10;                        if (server.getAuthenticationProvider().authenticate(this, elements[1], elements[2])) {&#10;                            break;&#10;                        }&#10;                        continue;&#10;                    }&#10;                    if (message.startsWith(&quot;/register &quot;)) {&#10;                        String[] elements = message.split(&quot; &quot;);&#10;                        if (elements.length != 4) {&#10;                            sendMessage(&quot;Неверный формат команды /register&quot;);&#10;                            continue;&#10;                        }&#10;                        if (server.getAuthenticationProvider().registration(this, elements[1], elements[2], elements[3])) {&#10;                            break;&#10;                        }&#10;                        continue;&#10;                    }&#10;                    sendMessage(&quot;Перед работой с чатом необходимо выполнить аутентификацию '/auth login password' или регистрацию '/register login password username'&quot;);&#10;                }&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.startsWith(&quot;/&quot;)) {&#10;                        if (message.equals(&quot;/exit&quot;)) {&#10;                            sendMessage(&quot;/exitok&quot;);&#10;                            break;&#10;                        } else if (message.startsWith(&quot;/w &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 3);&#10;                            if (parts.length == 3) {&#10;                                String recipient = parts[1];&#10;                                String privateMessage = parts[2];&#10;                                server.sendPrivateMessage(recipient, username + &quot; (личное сообщение): &quot; + privateMessage);&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат личного сообщения. Используйте: /w &lt;username&gt; &lt;message&gt;&quot;);&#10;                            }&#10;                        } else if (message.startsWith(&quot;/kick &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 2);&#10;                            if (parts.length == 2) {&#10;                                String userToKick = parts[1];&#10;                                String role = server.getAuthenticationProvider().getUserRole(username);&#10;                                if (Role.ADMIN.name().equals(role)) {&#10;                                    server.kickUser(userToKick);&#10;                                } else {&#10;                                    sendMessage(&quot;У вас нет прав для выполнения этой команды.&quot;);&#10;                                }&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат команды. Используйте: /kick &lt;username&gt;&quot;);&#10;                            }&#10;                        }&#10;                        continue;&#10;                    }&#10;                    server.broadcastMessage(username + &quot;: &quot; + message);&#10;                }&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            } finally {&#10;                disconnect();&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void sendMessage(String message) {&#10;        try {&#10;            out.writeUTF(message);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void disconnect() {&#10;        server.unsubscribe(this);&#10;        try {&#10;            if (in != null) {&#10;                in.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (out != null) {&#10;                out.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (socket != null) {&#10;                socket.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;Теперь пользователи с ролью `ADMIN` могут отключать других пользователей от чата с помощью команды `/kick &lt;username&gt;`." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1719913970789" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/enums/Role.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="ffece8">
          <value>
            <ChatHistoryModel>
              <option name="id" value="ffece8" />
              <option name="initiateTms" value="1719914031437" />
              <option name="isStopped" value="true" />
              <option name="request" value=" Просканируй ещё раз классы и напиши твое решение" />
              <option name="response" value="" />
              <option name="responseDescription" value="&lt;em&gt;Dynamic context. Adding files:&lt;br/&gt;&lt;/em&gt;&lt;em&gt;&#10;-server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java&#10;-server/src/main/java/ru/otus/java/basic/ClientHandler.java&#10;-server/src/main/java/ru/otus/java/basic/InMemoryAuthenticationProvider.java&#10;-server/src/main/java/ru/otus/java/basic/Server.java.&#10;&lt;/em&gt;&lt;em&gt;&#10;&#10;&lt;/em&gt;Конечно, давайте пересканируем классы и внесем необходимые изменения для реализации возможности отключения пользователей от чата с помощью команды «/kick username» для пользователей с ролью `ADMIN`.&#10;&#10;### Изменения в `InMemoryAuthenticationProvider.java`&#10;&#10;Добавим метод `getUserRole` для получения роли пользователя по логину:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import ru.otus.java.basic.enums.Role;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class InMemoryAuthenticationProvider implements AuthenticationProvider {&#10;    private class User {&#10;        private String login;&#10;        private String password;&#10;        private String username;&#10;        private String role;&#10;&#10;        public User(String login, String password, String username, String role) {&#10;            this.login = login;&#10;            this.password = password;&#10;            this.username = username;&#10;            this.role = role;&#10;        }&#10;&#10;        public String getLogin() {&#10;            return login;&#10;        }&#10;&#10;        public String getRole() {&#10;            return role;&#10;        }&#10;&#10;        public String getUsername() {&#10;            return username;&#10;        }&#10;    }&#10;&#10;    private Server server;&#10;    private List&lt;User&gt; users;&#10;&#10;    public InMemoryAuthenticationProvider(Server server) {&#10;        this.server = server;&#10;        this.users = new ArrayList&lt;&gt;();&#10;        this.users.add(new User(&quot;login1&quot;, &quot;pass1&quot;, &quot;bob&quot;, Role.ADMIN.name()));&#10;        this.users.add(new User(&quot;login2&quot;, &quot;pass2&quot;, &quot;user2&quot;, Role.USER.name()));&#10;        this.users.add(new User(&quot;login3&quot;, &quot;pass3&quot;, &quot;user3&quot;, Role.USER.name()));&#10;    }&#10;&#10;    @Override&#10;    public void initialize() {&#10;        System.out.println(&quot;Сервис аутентификации запущен: In-Memory режим&quot;);&#10;    }&#10;&#10;    private String getUsernameByLoginAndPassword(String login, String password) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login) &amp;&amp; u.password.equals(password)) {&#10;                return u.username;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private boolean isLoginAlreadyExist(String login) {&#10;        for (User u : users) {&#10;            if (u.login.equals(login)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private boolean isUsernameAlreadyExist(String username) {&#10;        for (User u : users) {&#10;            if (u.username.equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public synchronized boolean authenticate(ClientHandler clientHandler, String login, String password) {&#10;        String authUsername = getUsernameByLoginAndPassword(login, password);&#10;        if (authUsername == null) {&#10;            clientHandler.sendMessage(&quot;Некорректный логин/пароль&quot;);&#10;            return false;&#10;        }&#10;        if (server.isUsernameBusy(authUsername)) {&#10;            clientHandler.sendMessage(&quot;Указанная учетная запись уже занята&quot;);&#10;            return false;&#10;        }&#10;        clientHandler.setUsername(authUsername);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/authok &quot; + authUsername);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean registration(ClientHandler clientHandler, String login, String password, String username) {&#10;        if (login.trim().length() &lt; 3 || password.trim().length() &lt; 6 || username.trim().length() &lt; 1) {&#10;            clientHandler.sendMessage(&quot;Логин 3+ символа, Пароль 6+ символов, Имя пользователя 1+ символ&quot;);&#10;            return false;&#10;        }&#10;        if (isLoginAlreadyExist(login)) {&#10;            clientHandler.sendMessage(&quot;Указанный логин уже занят&quot;);&#10;            return false;&#10;        }&#10;        if (isUsernameAlreadyExist(username)) {&#10;            clientHandler.sendMessage(&quot;Указанное имя пользователя уже занято&quot;);&#10;            return false;&#10;        }&#10;        users.add(new User(login, password, username, Role.USER.name()));&#10;        clientHandler.setUsername(username);&#10;        server.subscribe(clientHandler);&#10;        clientHandler.sendMessage(&quot;/regok &quot; + username);&#10;        return true;&#10;    }&#10;&#10;    public boolean removeUserByLogin(String login) {&#10;        return users.removeIf(user -&gt; user.getLogin().equals(login));&#10;    }&#10;&#10;    public String getUserRole(String username) {&#10;        for (User user : users) {&#10;            if (user.getUsername().equals(username)) {&#10;                return user.getRole();&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `Server.java`&#10;&#10;Добавим метод `kickUser` для отключения пользователя:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class Server {&#10;    private int port;&#10;    private List&lt;ClientHandler&gt; clients;&#10;    private AuthenticationProvider authenticationProvider;&#10;&#10;    public AuthenticationProvider getAuthenticationProvider() {&#10;        return authenticationProvider;&#10;    }&#10;&#10;    public Server(int port) {&#10;        this.port = port;&#10;        this.clients = new ArrayList&lt;&gt;();&#10;        this.authenticationProvider = new InMemoryAuthenticationProvider(this);&#10;    }&#10;&#10;    public void start() {&#10;        try (ServerSocket serverSocket = new ServerSocket(port)) {&#10;            System.out.println(&quot;Сервер запущен на порту: &quot; + port);&#10;            authenticationProvider.initialize();&#10;            while (true) {&#10;                Socket socket = serverSocket.accept();&#10;                new ClientHandler(this, socket);&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public synchronized void subscribe(ClientHandler clientHandler) {&#10;        broadcastMessage(&quot;В чат зашел: &quot; + clientHandler.getUsername());&#10;        clients.add(clientHandler);&#10;    }&#10;&#10;    public synchronized void unsubscribe(ClientHandler clientHandler) {&#10;        clients.remove(clientHandler);&#10;        broadcastMessage(&quot;Из чата вышел: &quot; + clientHandler.getUsername());&#10;    }&#10;&#10;    public synchronized void broadcastMessage(String message) {&#10;        for (ClientHandler c : clients) {&#10;            c.sendMessage(message);&#10;        }&#10;    }&#10;&#10;    public synchronized void sendPrivateMessage(String recipientUsername, String message) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(recipientUsername)) {&#10;                client.sendMessage(message);&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    public synchronized void kickUser(String username) {&#10;        for (ClientHandler client : clients) {&#10;            if (client.getUsername().equals(username)) {&#10;                client.sendMessage(&quot;Вы были отключены от чата администратором.&quot;);&#10;                client.disconnect();&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    public boolean isUsernameBusy(String username) {&#10;        for (ClientHandler c : clients) {&#10;            if (c.getUsername().equals(username)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;}&#10;```&#10;&#10;### Изменения в `ClientHandler.java`&#10;&#10;Изменим обработку сообщений, чтобы поддерживать команду `/kick` для администраторов:&#10;&#10;```java&#10;package ru.otus.java.basic;&#10;&#10;import java.io.DataInputStream;&#10;import java.io.DataOutputStream;&#10;import java.io.IOException;&#10;import java.net.Socket;&#10;&#10;public class ClientHandler {&#10;    private Server server;&#10;    private Socket socket;&#10;    private DataInputStream in;&#10;    private DataOutputStream out;&#10;    private String username;&#10;&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    public void setUsername(String username) {&#10;        this.username = username;&#10;    }&#10;&#10;    public ClientHandler(Server server, Socket socket) throws IOException {&#10;        this.server = server;&#10;        this.socket = socket;&#10;        this.in = new DataInputStream(socket.getInputStream());&#10;        this.out = new DataOutputStream(socket.getOutputStream());&#10;        new Thread(() -&gt; {&#10;            try {&#10;                System.out.println(&quot;Подключился новый клиент&quot;);&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.equals(&quot;/exit&quot;)) {&#10;                        sendMessage(&quot;/exitok&quot;);&#10;                        return;&#10;                    }&#10;                    if (message.startsWith(&quot;/auth &quot;)) {&#10;                        String[] elements = message.split(&quot; &quot;);&#10;                        if (elements.length != 3) {&#10;                            sendMessage(&quot;Неверный формат команды /auth&quot;);&#10;                            continue;&#10;                        }&#10;                        if (server.getAuthenticationProvider().authenticate(this, elements[1], elements[2])) {&#10;                            break;&#10;                        }&#10;                        continue;&#10;                    }&#10;                    if (message.startsWith(&quot;/register &quot;)) {&#10;                        String[] elements = message.split(&quot; &quot;);&#10;                        if (elements.length != 4) {&#10;                            sendMessage(&quot;Неверный формат команды /register&quot;);&#10;                            continue;&#10;                        }&#10;                        if (server.getAuthenticationProvider().registration(this, elements[1], elements[2], elements[3])) {&#10;                            break;&#10;                        }&#10;                        continue;&#10;                    }&#10;                    sendMessage(&quot;Перед работой с чатом необходимо выполнить аутентификацию '/auth login password' или регистрацию '/register login password username'&quot;);&#10;                }&#10;                while (true) {&#10;                    String message = in.readUTF();&#10;                    if (message.startsWith(&quot;/&quot;)) {&#10;                        if (message.equals(&quot;/exit&quot;)) {&#10;                            sendMessage(&quot;/exitok&quot;);&#10;                            break;&#10;                        } else if (message.startsWith(&quot;/w &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 3);&#10;                            if (parts.length == 3) {&#10;                                String recipient = parts[1];&#10;                                String privateMessage = parts[2];&#10;                                server.sendPrivateMessage(recipient, username + &quot; (личное сообщение): &quot; + privateMessage);&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат личного сообщения. Используйте: /w &lt;username&gt; &lt;message&gt;&quot;);&#10;                            }&#10;                        } else if (message.startsWith(&quot;/kick &quot;)) {&#10;                            String[] parts = message.split(&quot; &quot;, 2);&#10;                            if (parts.length == 2) {&#10;                                String userToKick = parts[1];&#10;                                String role = server.getAuthenticationProvider().getUserRole(username);&#10;                                if (Role.ADMIN.name().equals(role)) {&#10;                                    server.kickUser(userToKick);&#10;                                } else {&#10;                                    sendMessage(&quot;У вас нет прав для выполнения этой команды.&quot;);&#10;                                }&#10;                            } else {&#10;                                sendMessage(&quot;Неправильный формат команды. Используйте: /kick &lt;username&gt;&quot;);&#10;                            }&#10;                        }&#10;                        continue;&#10;                    }&#10;                    server.broadcastMessage(username + &quot;: &quot; + message);&#10;                }&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            } finally {&#10;                disconnect();&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void sendMessage(String message) {&#10;        try {&#10;            out.writeUTF(message);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public void disconnect() {&#10;        server.unsubscribe(this);&#10;        try {&#10;            if (in != null) {&#10;                in.close();&#10;            }&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;        try {&#10;            if (out != null) {&#10;                out.close();&#10;            }&#10;        } catch (IOException e" />
              <option name="responseTms" value="1719914094270" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/AuthenticationProvider.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/Server.java" />
                  <option value="$PROJECT_DIR$/client/src/main/java/ru/otus/java/basic/Client.java" />
                  <option value="$PROJECT_DIR$/server/src/main/java/ru/otus/java/basic/ClientHandler.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>